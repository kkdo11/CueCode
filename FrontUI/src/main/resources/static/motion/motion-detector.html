<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <link rel="icon" href="data:,">
    <title>MotionLink Demo v0.5 - Save Motion</title>
    <style>
        body { font-family: sans-serif; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; margin: 0; background-color: #f0f0f0; }
        #container { position: relative; width: 640px; height: 480px; border: 2px solid #333; }
        #webcam { width: 100%; height: 100%; transform: scaleX(-1); }
        #output_canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; transform: scaleX(-1); }
        .status-container { margin-top: 10px; text-align: center; }
        .controls-container { margin-top: 15px; display: flex; align-items: center; gap: 10px; }
        #status { font-size: 1.2em; font-weight: bold; color: #333; min-height: 1.2em; }
        #ws_status, #recordStatus { font-size: 1em; color: #666; }
        button { padding: 10px 20px; font-size: 1em; color: white; border: none; border-radius: 8px; cursor: pointer; transition: background-color 0.2s; }
        button:disabled { background-color: #999; cursor: not-allowed; }
        #recordButton { background-color: #4F46E5; }
        #saveButton { background-color: #10B981; }
        input[type="text"] { padding: 10px; border-radius: 8px; border: 1px solid #ccc; }
    </style>
    <!-- 로컬 경로로 수정 -->
    <script type="module" src="/vendor/mediapipe/js/vision_bundle.js"></script>
</head>
<body>
<h1>MotionLink 실시간 동작 인식 데모 (v0.5 - 저장)</h1>
<div id="container">
    <video id="webcam" autoplay playsinline></video>
    <canvas id="output_canvas"></canvas>
</div>
<div class="status-container">
    <div id="status">상태: 초기화 중...</div>
    <div id="ws_status">WS: 연결 안됨</div>
    <div id="recordStatus">녹화: 대기 중</div>
</div>
<div class="controls-container">
    <button id="recordButton">3초 녹화 시작</button>
    <input type="text" id="motionLabel" placeholder="동작 이름 (예: 안녕하세요)">
    <button id="saveButton">동작 저장</button>
</div>

<script type="module">
    // === 설정 값 ===
    const API_GATEWAY_URL = "http://localhost:13000";
    const WEBSOCKET_URL = "ws://localhost:8000/ws/motion";
    const SEND_INTERVAL_MS = 100;
    const RECORDING_DURATION_MS = 3000;

    // === 전역 변수 ===
    const video = document.getElementById("webcam");
    const canvasElement = document.getElementById("output_canvas");
    const canvasCtx = canvasElement.getContext("2d");
    const statusDiv = document.getElementById("status");
    const wsStatusDiv = document.getElementById("ws_status");
    const recordStatusDiv = document.getElementById("recordStatus");
    const recordButton = document.getElementById("recordButton");
    const saveButton = document.getElementById("saveButton");
    const motionLabelInput = document.getElementById("motionLabel");

    const { FaceLandmarker, HandLandmarker, FilesetResolver, DrawingUtils } = await import("/vendor/mediapipe/js/vision_bundle.js");

    let faceLandmarker, handLandmarker, drawingUtils, socket;
    let lastVideoTime = -1, lastSendTime = 0;
    let isRecording = false, recordedFrames = [];

    // === WebSocket 설정 ===
    function initWebSocket() {
        console.log(`[WS] 연결 시도... (${WEBSOCKET_URL})`);
        wsStatusDiv.textContent = `WS: 연결 시도...`;
        socket = new WebSocket(WEBSOCKET_URL);
        socket.onopen = () => { console.log("[WS] 연결 성공!"); wsStatusDiv.textContent = "WS: 연결됨"; };
        socket.onmessage = (event) => { console.log("[WS] 서버로부터 메시지 수신:", event.data); statusDiv.textContent = `서버 응답: ${event.data}`; };
        socket.onclose = () => { console.warn("[WS] 연결이 닫혔습니다. 3초 후 재연결 시도..."); wsStatusDiv.textContent = "WS: 연결 끊김"; setTimeout(initWebSocket, 3000); };
        socket.onerror = (error) => { console.error("[WS] 오류 발생:", error); wsStatusDiv.textContent = "WS: 오류"; socket.close(); };
    }

    // === Helper: build compact feature vector matching server's ordering ===
    function buildCompactFeatures(frame) {
        // Prefer face blendshapes if present
        if (frame.face_blendshapes && Object.keys(frame.face_blendshapes).length > 0) {
            const keys = Object.keys(frame.face_blendshapes).sort();
            return { detectionArea: 'face', features: keys.map(k => Number(frame.face_blendshapes[k] || 0.0)) };
        }
        // Otherwise, try hand landmarks: flatten right then left, each point [x,y,z]
        const right = frame.right_hand_landmarks || frame.right_hand || null;
        const left = frame.left_hand_landmarks || frame.left_hand || null;
        if ((Array.isArray(right) && right.length > 0) || (Array.isArray(left) && left.length > 0)) {
            // determine max points (use whichever has points)
            const pointCount = Math.max((right && right.length) || 0, (left && left.length) || 0);
            const vec = [];
            // right hand
            for (let i = 0; i < pointCount; i++) {
                if (right && right[i] && right[i].length >= 3) { vec.push(Number(right[i][0]||0), Number(right[i][1]||0), Number(right[i][2]||0)); }
                else { vec.push(0,0,0); }
            }
            // left hand
            for (let i = 0; i < pointCount; i++) {
                if (left && left[i] && left[i].length >= 3) { vec.push(Number(left[i][0]||0), Number(left[i][1]||0), Number(left[i][2]||0)); }
                else { vec.push(0,0,0); }
            }
            return { detectionArea: 'hand', features: vec };
        }
        // Nothing available
        return null;
    }

    // === 데이터 처리 ===
    function processAndGetData(faceResults, handResults) {
        const faceBlendshapes = faceResults.faceBlendshapes.length > 0
            ? Object.fromEntries(faceResults.faceBlendshapes[0].categories.map(c => [c.categoryName, c.score]))
            : {};
        const getHandData = (handednesses, landmarks, handName) => {
            const handIndex = handednesses.findIndex(h => h[0].categoryName === handName);
            return handIndex > -1 ? landmarks[handIndex].map(p => [p.x, p.y, p.z]) : null;
        };
        const frame = {
            timestamp_ms: Date.now(),
            face_blendshapes: faceBlendshapes,
            left_hand_landmarks: getHandData(handResults.handednesses, handResults.landmarks, 'Left'),
            right_hand_landmarks: getHandData(handResults.handednesses, handResults.landmarks, 'Right')
        };
        return frame;
    }

    // Send one frame message over WS (if connected)
    function sendFrameOverWS(frame) {
        if (!socket || socket.readyState !== WebSocket.OPEN) return false;
        const compact = buildCompactFeatures(frame);
        if (!compact) return false;
        const msg = {
            type: 'frame',
            detectionArea: compact.detectionArea,
            timestamp_ms: frame.timestamp_ms,
            features: compact.features
        };
        socket.send(JSON.stringify(msg));
        return true;
    }

    // Send end message
    function sendEndOverWS(detectionArea) {
        if (!socket || socket.readyState !== WebSocket.OPEN) return false;
        const msg = { type: 'end', detectionArea: detectionArea };
        socket.send(JSON.stringify(msg));
        return true;
    }

    // === 녹화 및 저장 로직 ===
    recordButton.addEventListener('click', () => {
        if (isRecording) return;
        isRecording = true;
        recordedFrames = [];
        recordButton.disabled = true;
        motionLabelInput.value = '';
        saveButton.disabled = true;
        recordStatusDiv.textContent = "녹화 중... (3초)";
        console.log("[Record] 3초 녹화를 시작합니다.");

        // ensure websocket is connected
        if (!socket || socket.readyState !== WebSocket.OPEN) {
            initWebSocket();
        }

        // stop after duration and send 'end' to server for matching
        setTimeout(() => {
            isRecording = false;
            recordButton.disabled = false;
            saveButton.disabled = false;
            recordStatusDiv.textContent = `녹화 완료! 총 ${recordedFrames.length} 프레임 수집.`;
            console.log("[Record] 녹화 완료. 수집된 데이터:", recordedFrames);
            // send end with preferred detectionArea (if face data present use face else hand)
            const last = recordedFrames[recordedFrames.length-1];
            const detectionArea = (last && last.face_blendshapes && Object.keys(last.face_blendshapes).length>0) ? 'face' : 'hand';
            sendEndOverWS(detectionArea);
        }, RECORDING_DURATION_MS);
    });

    saveButton.addEventListener('click', async () => {
        const phrase = motionLabelInput.value;
        if (!phrase) { alert("동작 이름을 입력해주세요."); return; }
        if (recordedFrames.length === 0) { alert("먼저 동작을 녹화해주세요."); return; }

        // 데이터 재가공 로직
        const motionData = {
            face_blendshapes: recordedFrames.map(frame => ({
                timestamp_ms: frame.timestamp_ms,
                values: frame.face_blendshapes
            })),
            hand_landmarks: recordedFrames.map(frame => ({
                timestamp_ms: frame.timestamp_ms,
                left_hand: frame.left_hand_landmarks,
                right_hand: frame.right_hand_landmarks
            }))
        };

        const payload = {
            phrase: phrase,
            motion_type: "face_and_hand", // 임시값
            motion_data: motionData
        };

        console.log("[API] /motions/register API로 데이터 전송 시도...", payload);
        saveButton.disabled = true;
        saveButton.textContent = "저장 중...";

        try {
            const response = await fetch(`${API_GATEWAY_URL}/motions/register`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            if (response.ok) {
                const result = await response.text();
                alert(`저장 성공: ${result}`);
                motionLabelInput.value = '';
                recordedFrames = [];
                recordStatusDiv.textContent = "녹화: 대기 중";
            } else { throw new Error(`서버 오류: ${response.status}`); }
        } catch (error) {
            alert("저장 중 오류가 발생했습니다.");
            console.error("[API] 저장 실패:", error);
        } finally {
            saveButton.disabled = false;
            saveButton.textContent = "동작 저장";
        }
    });

    // === MediaPipe 초기화 및 웹캠 실행 ===
    async function createLandmarkers() {
        // 로컬 경로로 수정
        const vision = await FilesetResolver.forVisionTasks("/vendor/mediapipe/wasm");
        drawingUtils = new DrawingUtils(canvasCtx);
        faceLandmarker = await FaceLandmarker.createFromOptions(vision, { baseOptions: { modelAssetPath: `/vendor/mediapipe/models/face_landmarker.task`, delegate: "GPU" }, outputFaceBlendshapes: true, runningMode: "VIDEO", numFaces: 1 });
        handLandmarker = await HandLandmarker.createFromOptions(vision, { baseOptions: { modelAssetPath: `/vendor/mediapipe/models/hand_landmarker.task`, delegate: "GPU" }, runningMode: "VIDEO", numHands: 2 });
        statusDiv.textContent = "상태: 웹캠 로딩 중...";
    }
    function enableCam() {
        navigator.mediaDevices.getUserMedia({ video: true }).then((stream) => {
            video.srcObject = stream;
            video.addEventListener("loadeddata", predictWebcam);
        }).catch((err) => { console.error("Error accessing webcam: ", err); statusDiv.textContent = "오류: 웹캠 접근에 실패했습니다. 권한을 확인해주세요."; });
    }

    async function predictWebcam(time) {
        if (video.readyState < 2) { window.requestAnimationFrame(predictWebcam); return; }
        if (video.currentTime === lastVideoTime) { window.requestAnimationFrame(predictWebcam); return; }
        lastVideoTime = video.currentTime;

        const startTimeMs = performance.now();
        const faceResults = faceLandmarker.detectForVideo(video, startTimeMs);
        const handResults = handLandmarker.detectForVideo(video, startTimeMs);
        const currentFrameData = processAndGetData(faceResults, handResults);

        if (isRecording) {
            recordedFrames.push(currentFrameData);
            // throttle sending frames to SEND_INTERVAL_MS
            const now = Date.now();
            if (now - lastSendTime >= SEND_INTERVAL_MS) {
                lastSendTime = now;
                sendFrameOverWS(currentFrameData);
            }
        }

        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
        if (faceResults.faceLandmarks) { for (const landmarks of faceResults.faceLandmarks) { drawingUtils.drawConnectors(landmarks, FaceLandmarker.FACE_LANDMARKS_TESSELATION, { color: "#C0C0C070", lineWidth: 1 }); } }
        if (handResults.landmarks) { for (const landmarks of handResults.landmarks) { drawingUtils.drawConnectors(landmarks, HandLandmarker.HAND_CONNECTIONS, { color: "#00FF00", lineWidth: 5 }); drawingUtils.drawLandmarks(landmarks, { color: "#FF0000", lineWidth: 2 }); } }

        window.requestAnimationFrame(predictWebcam);
    }

    // === 실행 시작 ===
    async function main() {
        await createLandmarkers();
        enableCam();
        // Enable WebSocket for live matching
        initWebSocket();
    }

    main();
</script>
</body>
</html>